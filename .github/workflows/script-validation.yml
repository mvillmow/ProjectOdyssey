name: Script Validation

on:
  # Run on pull requests when scripts change
  pull_request:
    paths:
      - 'scripts/**/*.py'
      - '.github/workflows/script-validation.yml'

  # Run on pushes to main
  push:
    branches:
      - main
    paths:
      - 'scripts/**/*.py'
      - '.github/workflows/script-validation.yml'

  # Allow manual runs
  workflow_dispatch:

permissions:
  contents: read

jobs:
  validate-scripts:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up Pixi
        uses: prefix-dev/setup-pixi@v0.9.3
        with:
          pixi-version: latest
          cache: true

      - name: Install validation tools
        run: |
          pixi run pip install ruff pyyaml

      - name: Find Python scripts
        id: find-scripts
        run: |
          echo "Discovering Python scripts in scripts/ directory..."
          find scripts -name "*.py" -type f | tee /tmp/scripts_list.txt
          SCRIPT_COUNT=$(wc -l < /tmp/scripts_list.txt)
          echo "Found $SCRIPT_COUNT Python scripts"
          echo "script_count=$SCRIPT_COUNT" >> $GITHUB_OUTPUT

      - name: Syntax validation
        run: |
          echo "Validating Python syntax for all scripts..."
          EXIT_CODE=0
          while IFS= read -r script; do
            echo "Checking: $script"
            if ! python3 -m py_compile "$script"; then
              echo "❌ Syntax error in: $script"
              EXIT_CODE=1
            fi
          done < /tmp/scripts_list.txt

          if [ $EXIT_CODE -eq 0 ]; then
            echo "✅ All scripts have valid Python syntax"
          else
            echo "❌ Syntax validation failed"
          fi
          exit $EXIT_CODE

      - name: Lint with ruff
        run: |
          echo "Running ruff linter on all scripts..."
          pixi run ruff check scripts/ --output-format=github || {
            echo "❌ Linting issues found"
            echo ""
            echo "To fix locally:"
            echo "  pixi run pip install ruff"
            echo "  pixi run ruff check scripts/"
            echo "  pixi run ruff check scripts/ --fix  # Auto-fix some issues"
            exit 1
          }
          echo "✅ All scripts passed linting"

      - name: Check script formatting
        run: |
          echo "Checking code formatting with ruff..."
          pixi run ruff format --check scripts/ || {
            echo "❌ Formatting issues found"
            echo ""
            echo "To fix locally:"
            echo "  pixi run ruff format scripts/"
            exit 1
          }
          echo "✅ All scripts are properly formatted"

      - name: Validate imports
        run: |
          echo "Validating import statements..."
          EXIT_CODE=0

          # Check for common import issues
          while IFS= read -r script; do
            # Skip __pycache__ and other non-script files
            if [[ "$script" == *"__pycache__"* ]]; then
              continue
            fi

            echo "Checking imports in: $script"

            # Check if script uses common.py and has proper path setup
            if grep -q "from common import" "$script" && ! grep -q "sys.path.insert" "$script"; then
              # Check if script is in scripts/ root (can import directly)
              if [[ "$script" == scripts/[^/]*.py ]]; then
                echo "  ✓ Script in root can import common directly"
              else
                echo "  ⚠ Script uses 'from common import' but may need sys.path.insert"
              fi
            fi

            # Try importing to verify dependencies are available
            if ! python3 -c "import sys; sys.path.insert(0, 'scripts'); exec(open('$script').read().split('if __name__')[0])" 2>/dev/null; then
              # This is not necessarily an error - some scripts may need special dependencies
              echo "  ℹ Script has external dependencies or runtime requirements"
            fi
          done < /tmp/scripts_list.txt

          echo "✅ Import validation complete"

      - name: Run executable scripts with --help
        run: |
          echo "Testing executable scripts with --help flag..."
          EXIT_CODE=0
          TESTED=0

          while IFS= read -r script; do
            # Skip test files and playground scripts
            if [[ "$script" == *"/tests/"* ]] || [[ "$script" == *"/playground/"* ]]; then
              continue
            fi

            # Skip non-executable scripts (libraries)
            if ! grep -q "if __name__ == '__main__'" "$script"; then
              continue
            fi

            echo "Testing: $script"
            TESTED=$((TESTED + 1))

            # Try --help flag (common pattern)
            if python3 "$script" --help &>/dev/null; then
              echo "  ✓ Accepts --help flag"
            elif python3 "$script" -h &>/dev/null; then
              echo "  ✓ Accepts -h flag"
            else
              echo "  ℹ Script does not support --help (may be expected)"
            fi
          done < /tmp/scripts_list.txt

          echo "✅ Tested $TESTED executable scripts"

      - name: Validate script shebangs
        run: |
          echo "Checking shebang lines..."
          EXIT_CODE=0

          while IFS= read -r script; do
            if head -n1 "$script" | grep -q "^#!/usr/bin/env python3"; then
              echo "✓ $script has correct shebang"
            elif head -n1 "$script" | grep -q "^#!"; then
              echo "⚠ $script has unexpected shebang: $(head -n1 "$script")"
            else
              echo "ℹ $script has no shebang (may be a library module)"
            fi
          done < /tmp/scripts_list.txt

          echo "✅ Shebang validation complete"

      - name: Check for common issues
        run: |
          echo "Checking for common code issues..."
          EXIT_CODE=0

          # Check for print() without file= in error messages
          if grep -r "print.*[Ee]rror" scripts/ --include="*.py" | grep -v "file=sys.stderr" | grep -v "# noqa"; then
            echo "⚠ Found print() statements for errors that should use file=sys.stderr"
          fi

          # Check for TODO/FIXME comments
          if grep -rn "TODO\|FIXME" scripts/ --include="*.py"; then
            echo "ℹ Found TODO/FIXME comments (informational only)"
          fi

          echo "✅ Common issues check complete"

      - name: Summary
        if: always()
        run: |
          echo ""
          echo "================================"
          echo "Script Validation Summary"
          echo "================================"
          echo "Total scripts found: ${{ steps.find-scripts.outputs.script_count }}"
          echo ""
          echo "Checks performed:"
          echo "  ✓ Syntax validation (py_compile)"
          echo "  ✓ Linting (ruff)"
          echo "  ✓ Formatting (ruff format)"
          echo "  ✓ Import validation"
          echo "  ✓ Executable script testing"
          echo "  ✓ Shebang validation"
          echo "  ✓ Common issues check"
          echo ""
          echo "See job logs above for details"
          echo "================================"

      - name: Display helpful message on failure
        if: failure()
        run: |
          echo ""
          echo "❌ Script validation failed!"
          echo ""
          echo "To fix issues locally:"
          echo "  1. Install tools: pixi run pip install ruff pyyaml"
          echo "  2. Check syntax: python3 -m py_compile scripts/yourscript.py"
          echo "  3. Run linter: pixi run ruff check scripts/"
          echo "  4. Auto-fix lint issues: pixi run ruff check scripts/ --fix"
          echo "  5. Format code: pixi run ruff format scripts/"
          echo ""
          echo "For import errors, ensure scripts/common.py is accessible"
          echo "For scripts in subdirectories, use: sys.path.insert(0, str(Path(__file__).parent.parent))"
          echo ""
