# Day Twenty-One: From Just to Make

**Project:** ML Odyssey Manual
**Date:** December 21, 2025
**Branch:** `main`
**Tags:** #build-system #makefile #justfile #developer-experience #tooling #flexibility

---

## TL;DR

Hitting the limits of justfile's flexibility. The project needs a build interface supporting patterns like `compile.release.asan` and `install.debug.grpc`—sparse, combinatorial options across multiple dimensions (build mode, sanitizers, profiling, platform, architecture). Justfile doesn't support suffix matching like make does, forcing explicit enumeration of every combination. This violates DRY and becomes unmaintainable as the build matrix grows. Moving to makefiles with pattern rules—a proven approach from production use at AMD, NVidia, and Oxmiq Labs. Makefiles handle sparse multi-dimensional tensors of build options elegantly.

**Key insight:** Sometimes the old tools are still the right tools. Make's suffix matching wasn't just a clever trick—it was designed exactly for this use case.

---

## The Problem

I've been trying to get justfile to do what I want, but it just isn't as flexible as makefiles when running a developer interface.

### The Desired Interface

I want to support command patterns like:

```bash
just compile.release          # Compile in release mode
just compile.debug            # Compile in debug mode
just install.release          # Install release build
just install.release.asan     # Install with AddressSanitizer in release
just compile.asan             # AddressSanitizer build (defaults to debug)
just test.tsan.native         # ThreadSanitizer tests running natively (not Docker)
```

### The Pattern

The basic pattern is `<base-command>[.<modifier>]+` with sane defaults:

- **Base commands**: `compile`, `test`, `install`, `clean`
- **Modifiers**: `.debug`, `.release`, `.asan`, `.tsan`, `.grpc`, `.native`, `.coverage`
- **Defaults**: If no mode specified, assume debug; if no platform, assume Docker

This creates a sparse, composable interface where users only specify what differs from defaults.

---

## The Build Matrix

The problem gets complex fast. The dimensions are:

1. **Compilation modes**: `O0`, `O1`, `debug`, `release`
2. **Sanitizer options**: `asan`, `tsan`, `ubsan`, `lsan`, `msan`
3. **Profiling options**: `profile` on/off, `coverage` on/off
4. **Platform**: `windows`, `mac`, `linux`
5. **Architecture**: `x86`, `arm`, `powerpc`, `riscv`
6. **Feature flags**: `grpc`, `fuzz`, etc.

This is a **sparse multi-dimensional tensor** of options:

- Not all combinations are valid (tsan + asan are incompatible)
- Not all combinations are useful (most development happens on one platform)
- But the valid subset is large and unpredictable

### Why Justfile Fails

Justfile doesn't have suffix matching like make does. To support `compile.release.asan`, I have to explicitly define:

```justfile
compile.release.asan:
    # Build with release + asan flags

compile.debug.asan:
    # Build with debug + asan flags

compile.release.tsan:
    # Build with release + tsan flags

# ... and on and on for every combination
```

This causes massive code duplication, violating DRY. As the build matrix grows (6+ dimensions), the duplication becomes unmaintainable.

---

## The Makefile Solution

Make solves this with pattern rules and suffix matching. The entire build matrix can be expressed concisely:

```makefile
# Simplified Project Makefile
# Public targets: compile, test, install, help
# Modifiers are appended as suffixes (e.g. .asan, .native, .release)

# -----------------------------------------------------------------------------
# Configuration
# -----------------------------------------------------------------------------

NPROC ?= $(shell nproc 2>/dev/null || sysctl -n hw.ncpu 2>/dev/null || echo 4)
PREFIX ?= /usr/local

BUILD_ROOT ?= build
BUILD_SUBDIR ?= default
BUILD_DIR := $(BUILD_ROOT)/$(BUILD_SUBDIR)

CMAKE_BUILD_TYPE ?= Debug
BUILD_FLAGS ?=

# Placeholder flags
BUILD_FLAGS_debug   := -O0 -g -D_DEBUG
BUILD_FLAGS_release := -O3 -DNDEBUG
BUILD_FLAGS_asan    := -fsanitize=address
BUILD_FLAGS_ubsan   := -fsanitize=undefined
BUILD_FLAGS_lsan    := -fsanitize=leak
BUILD_FLAGS_tsan    := -fsanitize=thread
BUILD_FLAGS_msan    := -fsanitize=memory

# Docker vs native (placeholder behavior)
ifeq ($(NATIVE),1)
DOCKER_PREFIX :=
else
DOCKER_PREFIX := echo "[docker exec]"
endif

# -----------------------------------------------------------------------------
# Internal helpers
# -----------------------------------------------------------------------------

$(BUILD_DIR):
	@echo "Creating build directory: $(BUILD_DIR)"
	@mkdir -p $(BUILD_DIR)

# -----------------------------------------------------------------------------
# Public targets (ONLY these)
# -----------------------------------------------------------------------------

.PHONY: compile
compile: $(BUILD_DIR)
	@echo ">>> PLACEHOLDER: compile"
	@echo " - Build dir: $(BUILD_DIR)"
	@echo " - CMAKE_BUILD_TYPE: $(CMAKE_BUILD_TYPE)"
	@echo " - BUILD_FLAGS: $(BUILD_FLAGS)"
	@echo " # Example:"
	@echo " #   cmake -S . -B $(BUILD_DIR) -DCMAKE_BUILD_TYPE=$(CMAKE_BUILD_TYPE)"
	@echo " #   cmake --build $(BUILD_DIR) -j$(NPROC)"

.PHONY: test
test: compile
	@echo ">>> PLACEHOLDER: test"
	@echo " - Using build dir: $(BUILD_DIR)"
	@echo " # Example:"
	@echo " #   cd $(BUILD_DIR) && ctest --output-on-failure -j$(NPROC)"

.PHONY: install
install: compile
	@echo ">>> PLACEHOLDER: install"
	@echo " - Prefix: $(PREFIX)"
	@echo " # Example:"
	@echo " #   cmake --install $(BUILD_DIR) --prefix $(PREFIX)"

# -----------------------------------------------------------------------------
# Modifier patterns (integrated, unchanged in spirit)
# -----------------------------------------------------------------------------

# Native execution
%.native:
	@$(MAKE) $* NATIVE=1

# Sanitizers
%.asan:
	@$(MAKE) $* \
	    BUILD_FLAGS="$(BUILD_FLAGS) $(BUILD_FLAGS_asan)" \
	    BUILD_SUBDIR="$(BUILD_SUBDIR)$(suffix $@)"

%.ubsan:
	@$(MAKE) $* \
	    BUILD_FLAGS="$(BUILD_FLAGS) $(BUILD_FLAGS_ubsan)" \
	    BUILD_SUBDIR="$(BUILD_SUBDIR)$(suffix $@)"

%.lsan:
	@$(MAKE) $* \
	    BUILD_FLAGS="$(BUILD_FLAGS) $(BUILD_FLAGS_lsan)" \
	    BUILD_SUBDIR="$(BUILD_SUBDIR)$(suffix $@)"

%.tsan:
	@$(MAKE) $* \
	    BUILD_FLAGS="$(BUILD_FLAGS) $(BUILD_FLAGS_tsan)" \
	    BUILD_SUBDIR="$(BUILD_SUBDIR)$(suffix $@)"

%.msan:
	@$(MAKE) $* \
	    BUILD_FLAGS="$(BUILD_FLAGS) $(BUILD_FLAGS_msan)" \
	    BUILD_SUBDIR="$(BUILD_SUBDIR)$(suffix $@)"

# Feature flags
%.grpc:
	@$(MAKE) $* \
	    BUILD_FLAGS="$(BUILD_FLAGS) -DENABLE_GRPC=ON" \
	    BUILD_SUBDIR="$(BUILD_SUBDIR)$(suffix $@)"

%.coverage:
	@$(MAKE) $* \
	    BUILD_FLAGS="$(BUILD_FLAGS) -DENABLE_COVERAGE=ON" \
	    BUILD_SUBDIR="$(BUILD_SUBDIR)$(suffix $@)"

%.profile:
	@$(MAKE) $* \
	    BUILD_FLAGS="$(BUILD_FLAGS) -DENABLE_PROFILING=ON" \
	    BUILD_SUBDIR="$(BUILD_SUBDIR)$(suffix $@)"

%.fuzz:
	@$(MAKE) $* \
	    BUILD_FLAGS="$(BUILD_FLAGS) -DENABLE_FUZZING=ON" \
	    BUILD_SUBDIR="$(BUILD_SUBDIR)$(suffix $@)"

# Build type selectors
%.debug:
	@$(MAKE) $* \
	    BUILD_FLAGS="$(BUILD_FLAGS) $(BUILD_FLAGS_debug)" \
	    CMAKE_BUILD_TYPE=Debug \
	    BUILD_SUBDIR="$(BUILD_SUBDIR)$(suffix $@)"

%.release:
	@$(MAKE) $* \
	    BUILD_FLAGS="$(BUILD_FLAGS) $(BUILD_FLAGS_release)" \
	    CMAKE_BUILD_TYPE=Release \
	    BUILD_SUBDIR="$(BUILD_SUBDIR)$(suffix $@)"

# -----------------------------------------------------------------------------
# Help
# -----------------------------------------------------------------------------

.PHONY: help
help:
	@echo ""
	@echo "Simplified Makefile (baseline targets only)"
	@echo ""
	@echo "Public targets:"
	@echo "  make compile"
	@echo "  make test"
	@echo "  make install"
	@echo ""
	@echo "Modifiers (append to any target):"
	@echo "  .debug        Debug build (default)"
	@echo "  .release      Release build"
	@echo "  .asan         AddressSanitizer"
	@echo "  .ubsan        UndefinedBehaviorSanitizer"
	@echo "  .tsan         ThreadSanitizer"
	@echo "  .lsan         LeakSanitizer"
	@echo "  .msan         MemorySanitizer"
	@echo "  .grpc         Enable gRPC"
	@echo "  .coverage     Enable coverage"
	@echo "  .profile      Enable profiling"
	@echo "  .fuzz         Enable fuzzing"
	@echo "  .native       Run on host instead of Docker"
	@echo ""
	@echo "Examples:"
	@echo "  make compile"
	@echo "  make test.asan"
	@echo "  make compile.release.native"
	@echo "  make install.debug.grpc"
	@echo ""
```

### How Pattern Rules Work

The key is the `%` pattern and recursive make:

```makefile
%.asan:
	@$(MAKE) $* \
	    BUILD_FLAGS="$(BUILD_FLAGS) $(BUILD_FLAGS_asan)" \
	    BUILD_SUBDIR="$(BUILD_SUBDIR)$(suffix $@)"
```

When you run `make compile.release.asan`:

1. Make matches `.asan` suffix, strips it, leaving `compile.release`
2. Recursively calls `make compile.release` with asan flags added
3. Make matches `.release` suffix, strips it, leaving `compile`
4. Recursively calls `make compile` with release flags added
5. Finally runs the base `compile` target with accumulated flags

The pattern rules compose automatically. No explicit enumeration needed.

---

## Why This Matters

This isn't premature optimization—it's a pattern I've used successfully at:

- **AMD** - Complex cross-compilation builds for GPU drivers
- **NVidia** - Multi-platform CUDA toolkit builds
- **Oxmiq Labs** - Quantum simulation builds with extensive profiling options
- **Internal projects** - Embedded systems with architecture-specific optimizations

The makefile pattern handles sparse build matrices elegantly because:

1. **DRY**: Each modifier defined once, composes automatically
2. **Maintainable**: Adding a new sanitizer is one pattern rule, not N combinations
3. **Discoverable**: `make help` shows all modifiers, examples demonstrate composition
4. **Flexible**: Users compose exactly the build they need
5. **Correct**: Build directory isolation prevents option conflicts

---

## What's Next

### Immediate Priorities

1. **Implement the makefile** - Port justfile recipes to make pattern rules
2. **Test composition** - Verify modifier stacking works correctly
3. **Document patterns** - Update CLAUDE.md with makefile conventions
4. **Validate CI integration** - Ensure CI workflows call make correctly
5. **Deprecate justfile** - Keep it temporarily for backward compatibility, remove after transition

### Why Now

The build system needs flexibility for:

- **Multi-platform testing** - Linux, macOS, Windows builds in CI
- **Sanitizer validation** - ASAN/TSAN/UBSAN for memory safety
- **Performance profiling** - Profile-guided optimization experiments
- **Cross-compilation** - ARM builds for embedded targets (future work)

Justfile works fine for simple cases. But as the project matures, the build matrix will only grow more complex. Better to establish the right foundation now.

---

## Reflections

This decision taught me about tool selection and pragmatism:

1. **New isn't always better** - Justfile is modern, rust-based, well-designed. But make's 40+ years of evolution solved this exact problem. The old tool is still the right tool for this use case.

2. **Flexibility has a cost** - Justfile's simplicity is a feature for simple builds. But the simplicity becomes a limitation when you need sophisticated pattern matching. There's no free lunch.

3. **Battle-tested patterns matter** - I've used makefile suffix matching in production at 3+ companies. It works. The confidence from proven patterns outweighs the appeal of new tools.

4. **DRY isn't just aesthetics** - Code duplication creates maintenance burden. With 6+ build dimensions, explicit enumeration would mean hundreds of redundant recipes. Pattern rules reduce that to 10-15 concise rules.

5. **Developer experience drives adoption** - `make compile.release.asan` is intuitive. Adding `.tsan` or `.grpc` is discoverable. The interface teaches itself through consistency.

Sometimes the right tool isn't the newest tool. It's the one designed exactly for the problem you're solving. Make's suffix matching wasn't a hack—it was a deliberate design for combinatorial build options. 40 years later, that design still works.

---

**Status:** Build system migration planned, makefile patterns designed, justfile to be deprecated post-transition

**Next:** Implement makefile, test composition, update CI workflows, document conventions in CLAUDE.md

### Stats: Build Matrix Complexity

**Dimensions:**

- **5 base commands**: `compile`, `test`, `install`, `clean`, `format`
- **2 build types**: `debug`, `release`
- **5 sanitizers**: `asan`, `tsan`, `ubsan`, `lsan`, `msan`
- **4 feature flags**: `grpc`, `coverage`, `profile`, `fuzz`
- **2 platforms**: `native`, `docker`

**Theoretical combinations:** 5 x 2 x 5 x 4 x 2 = 400 distinct builds

**Practical useful subset:** ~50-80 builds (sparse matrix)

**Justfile approach:** Would require explicit enumeration of all useful combinations (50-80 recipes minimum)

**Makefile approach:** 5 base targets + 12 pattern rules = 17 definitions total

**Reduction:** 80 -> 17 definitions (78% less code, 100% more maintainable)

---

**Pattern observed:** Hitting tool limitations. When the problem space (combinatorial build options) exceeds the tool's abstraction capabilities (no suffix matching), choose the tool designed for the problem (make) rather than forcing the simpler tool (just) to do what it can't.
